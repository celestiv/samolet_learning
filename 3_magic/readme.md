# Магические методы

## Жизненный цикл объекта. Создание и уничтожение объектов
В Python существуют методы, которые называются магическими или специальными методами. 
Они автоматически вызываются в ответ на определенные операции и играют ключевую роль в реализации 
и интерпретации различных функций и операторов. Эти методы отвечают за операторы сравнения, 
арифметические операции, а также за другие действия, такие как доступ к элементам коллекции, 
определение количества элементов в ней, и обращение к атрибутам объекта

При создании объекта у класса вызывается метод `__new__()`, который возвращает экземпляр класса. 
Затем интерпретатор вызывает у созданного объекта метод `__init__(self, *args, **kwargs)`, 
передавая `self` в качестве первого аргумента.
Python активно использует механизм подсчета ссылок для управления памятью. Каждый раз, 
когда объект присваивается переменной или становится атрибутом другого объекта, 
счетчик ссылок на этот объект увеличивается. Например, при выполнении `a = b = some_object`, 
счетчик ссылок `some_object` увеличивается на два. В обратном случае, когда ссылка на объект 
удаляется или переменная получает новое значение, счетчик уменьшается. Например, 
если после вышеупомянутого присвоения подставить `a = None`, счетчик ссылок `some_object` уменьшится на один.

### Метод `__new__`

Метод `__new__(cls, *args, **kwargs)` является классовым методом и вызывается еще до создания экземпляра класса. 
Он отвечает за сам процесс создания объекта, где `cls` обозначает класс. Оставшиеся аргументы `*args` и `**kwargs` 
предназначены для `__init__`, следовательно, интерфейсы этих методов должны быть согласованы.
Примечательно, что если результат работы `__new__` представляет собой объект другого типа, то `__init__` не вызывается. 
Например, если `__new__` в классе `A` создает экземпляр класса `B`, инициализатор `__init__` для `A` игнорируется.

### Метод `__del__`  

Метод `__del__` функционирует как финализатор объекта, но его вызов не гарантирован.
Это означает, что если объект существует до завершения работы скрипта, `__del__` может не быть вызван.

## atttributes

Давайте разберемся, что происходит при обращении к атрибуту объекта, например `a.attr`. 
Атрибут `attr` может представлять собой как поле класса, так и метод. 
В каждом случае процесс обращения имеет свои особенности.

* Вызов `__getattribute__`. В первую очередь при обращении к атрибуту, например `a.attr`,
    вызывается метод `a.__getattribute__("attr")`. Этот метод отвечает за получение значения атрибута,
    если он существует.
* Обработка `AttributeError` и вызов `__getattr__`. Если при вызове `__getattribute__`
    возникает исключение `AttributeError` (то есть атрибут не найден), Python автоматически вызывает метод 
    `a.__getattr__("attr")`.
* Роль метода `__getattr__`. Метод `__getattr__` используется для определения поведения объекта в случае,
    если запрашиваемый атрибут отсутствует. Этот метод часто применяется для реализации вычисляемых атрибутов.
* Поиск в `__dict__` и классах. Если атрибут не найден с помощью `__getattribute__`,
    Python по умолчанию ищет атрибут в `__dict__` экземпляра, а затем у класса и его родителей. 
    Это стандартный механизм поиска атрибутов.
* Поиск атрибутов с двойным подчеркиванием. Для атрибутов, начинающихся с двойного нижнего подчеркивания,
    поиск происходит напрямую в классе, что является частью механизма инкапсуляции в Python.
* Завершение поиска атрибута. Если атрибут так и не был найден, процесс поиска завершается.
  Важно отметить, что у базового класса `object` нет необходимости в реализации `__getattr__`,
  поскольку он вызывается только когда `__getattribute__` не может найти атрибут.

Обратите внимание, как работают методы `__getattribute__` и `__getattr__`. Метод `__getattribute__` вызывается всегда,
когда происходит попытка доступа к атрибуту, вне зависимости от того, существует атрибут или нет. 
Если атрибут не существует, после `__getattribute__` вызывается `__getattr__`.

## Методы доступа к атрибутам: getters, setters
Если стандартного доступа к атрибутам через точку недостаточно, можно реализовать свои функции для получения и 
установки значения отдельного атрибута. Например, в случае, когда какое-то свойство объекта не имеет смысла хранить,
его нужно вычислять динамически, можно реализовать свой getter, а если нужно валидировать или преобразовывать 
устанавливаемое значение — setter.
Вместо изменения `__setattr__`, `__getattribute__` можно для некоторого свойства ` x` написать методы `get_x(self)`,
`set_x(self, value)`. Однако более удобным способом является использование декоратора `@property`.

`
class C:
    def __init__(self, kg: float):
        self.mass_kg = kg
    
    @property
    def mass_g(self):
        return self.mass_kg * 1000

    @mass_g.setter
    def mass_g(self, mass_g: float):
        self.mass_kg = mass_g / 1000

c = C(2)
assert c.mass_g == 2000
c.mass_g = 4000
assert c.mass_kg == 4
assert c.mass_g == 4000
`