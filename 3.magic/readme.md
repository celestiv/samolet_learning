# Магические методы

## Жизненный цикл объекта. Создание и уничтожение объектов
В Python существуют методы, которые называются магическими или специальными методами. 
Они автоматически вызываются в ответ на определенные операции и играют ключевую роль в реализации 
и интерпретации различных функций и операторов. Эти методы отвечают за операторы сравнения, 
арифметические операции, а также за другие действия, такие как доступ к элементам коллекции, 
определение количества элементов в ней, и обращение к атрибутам объекта

При создании объекта у класса вызывается метод `__new__()`, который возвращает экземпляр класса. 
Затем интерпретатор вызывает у созданного объекта метод `__init__(self, *args, **kwargs)`, 
передавая `self` в качестве первого аргумента.
Python активно использует механизм подсчета ссылок для управления памятью. Каждый раз, 
когда объект присваивается переменной или становится атрибутом другого объекта, 
счетчик ссылок на этот объект увеличивается. Например, при выполнении `a = b = some_object`, 
счетчик ссылок `some_object` увеличивается на два. В обратном случае, когда ссылка на объект 
удаляется или переменная получает новое значение, счетчик уменьшается. Например, 
если после вышеупомянутого присвоения подставить `a = None`, счетчик ссылок `some_object` уменьшится на один.

### Метод `__new__`

Метод `__new__(cls, *args, **kwargs)` является классовым методом и вызывается еще до создания экземпляра класса. 
Он отвечает за сам процесс создания объекта, где `cls` обозначает класс. Оставшиеся аргументы `*args` и `**kwargs` 
предназначены для `__init__`, следовательно, интерфейсы этих методов должны быть согласованы.
Примечательно, что если результат работы `__new__` представляет собой объект другого типа, то `__init__` не вызывается. 
Например, если `__new__` в классе `A` создает экземпляр класса `B`, инициализатор `__init__` для `A` игнорируется.

### Метод `__del__`  

Метод `__del__` функционирует как финализатор объекта, но его вызов не гарантирован.
Это означает, что если объект существует до завершения работы скрипта, `__del__` может не быть вызван.

## atttributes

Давайте разберемся, что происходит при обращении к атрибуту объекта, например `a.attr`. 
Атрибут `attr` может представлять собой как поле класса, так и метод. 
В каждом случае процесс обращения имеет свои особенности.

* Вызов `__getattribute__`. В первую очередь при обращении к атрибуту, например `a.attr`,
    вызывается метод `a.__getattribute__("attr")`. Этот метод отвечает за получение значения атрибута,
    если он существует.
* Обработка `AttributeError` и вызов `__getattr__`. Если при вызове `__getattribute__`
    возникает исключение `AttributeError` (то есть атрибут не найден), Python автоматически вызывает метод 
    `a.__getattr__("attr")`.
* Роль метода `__getattr__`. Метод `__getattr__` используется для определения поведения объекта в случае,
    если запрашиваемый атрибут отсутствует. Этот метод часто применяется для реализации вычисляемых атрибутов.
* Поиск в `__dict__` и классах. Если атрибут не найден с помощью `__getattribute__`,
    Python по умолчанию ищет атрибут в `__dict__` экземпляра, а затем у класса и его родителей. 
    Это стандартный механизм поиска атрибутов.
* Поиск атрибутов с двойным подчеркиванием. Для атрибутов, начинающихся с двойного нижнего подчеркивания,
    поиск происходит напрямую в классе, что является частью механизма инкапсуляции в Python.
* Завершение поиска атрибута. Если атрибут так и не был найден, процесс поиска завершается.
  Важно отметить, что у базового класса `object` нет необходимости в реализации `__getattr__`,
  поскольку он вызывается только когда `__getattribute__` не может найти атрибут.

Обратите внимание, как работают методы `__getattribute__` и `__getattr__`. Метод `__getattribute__` вызывается всегда,
когда происходит попытка доступа к атрибуту, вне зависимости от того, существует атрибут или нет. 
Если атрибут не существует, после `__getattribute__` вызывается `__getattr__`.

## Методы доступа к атрибутам: getters, setters
Если стандартного доступа к атрибутам через точку недостаточно, можно реализовать свои функции для получения и 
установки значения отдельного атрибута. Например, в случае, когда какое-то свойство объекта не имеет смысла хранить,
его нужно вычислять динамически, можно реализовать свой getter, а если нужно валидировать или преобразовывать 
устанавливаемое значение — setter.
Вместо изменения `__setattr__`, `__getattribute__` можно для некоторого свойства ` x` написать методы `get_x(self)`,
`set_x(self, value)`. Однако более удобным способом является использование декоратора `@property`.

## Использование функций `getattr`, `setattr`, `hasattr`, `delattr`

Python предоставляет встроенные, т.е. доступные без импорта каких-либо библиотек, функции для доступа к атрибутам 
объектов. Рассмотрим их подробнее.
Функция `getattr(obj: object, name: str[, default: object])` служит для получения значения атрибута с именем `name`. 
Вызов функции `getattr(obj, "attr")` соответствует следующему блоку кода:

Функция `hasattr(obj: object, name: str)` служит для проверки наличия атрибута с именем `name` у объекта. 
Она реализована через попытку вызова `getattr` и проверку на возникновение исключения `AttributeError`:

Функция `setattr(object: object, name: str, value: Any)` позволяет установить значение атрибута с именем `name` 
в значение `value`. Вызов данной функции осуществляет те же действия, что и конструкция `obj.attr = value`, 
где `attr` — значение параметра `name`. Есть исключение: с помощью `setattr` можно создать атрибут с именем, 
не соответствующим правилам для идентификаторов. В этом случае такой атрибут не будет доступен через точку, 
но можно получить к нему доступ с помощью функции `getattr`. Пример:

Функция `delattr(object: object, name: str)` удаляет у объекта атрибут с заданным именем, ее работа аналогична 
оператору `del object.attr`.

Функции `getattr`, `setattr`, `hasattr`, `delattr` в Python играют ключевую роль в динамическом взаимодействии с
атрибутами объектов. Эти функции особенно полезны, когда имя атрибута неизвестно заранее или когда требуется 
динамически управлять атрибутами в цикле. Например, `getattr` позволяет получить значение атрибута по его имени, 
предоставленному в виде строки, и даже задать значение по умолчанию с помощью параметра `default`, 
если атрибут отсутствует.

В то же время в Python обычно предпочтительнее использовать прямой доступ к атрибутам через точку, 
если имя атрибута известно. Для проверки наличия атрибута часто используется блок `try…except AttributeError`, 
который считается более идиоматичным по сравнению с `hasattr`.

## Что такое оператор `with`

Оператор `with` в Python обеспечивает управление ресурсами, автоматически выполняя настройку и очистку. 
При его использовании сначала выполняется выражение, возвращающее объект управления контекстом. 
После выполнения блока кода внутри `with`, этот объект заботится о закрытии или освобождении ресурсов, 
даже если в коде возникли исключения.

Преимущества применения оператора `with`:
- Более безопасное и удобное управление ресурсами по сравнению с соответствующей конструкцией `try..finally`.
- Предотвращение утечки ресурсов.
- Инкапсулирование логики обработки исключений в менеджерах контекста.
- Возможность переиспользовать код, который автоматически делает некоторые предварительные и 
заключительные действия (setup, teardown)

## Краткое описание популярных стандартных менеджеров контекста
В этом разделе рассмотрим несколько популярных стандартных менеджеров контекста. Они представляют собой практические примеры использования оператора `with` для управления различными ресурсами и обеспечения безопасности кода.
В стандартной библиотеке Python доступно несколько готовых менеджеров контекста:
1. `threading.Lock` обеспечивает потокобезопасность при работе с общими ресурсами между несколькими потоками.
`decimal.localcontext` управляет контекстом десятичных чисел, позволяя временно изменить настройки округления и точности для операций с ними.
`contextlib.closing` автоматически закрывает объект после использования, даже если он не является файлом.
`contextlib.redirect_stdout` и `contextlib.redirect_stderr` перенаправляют стандартный вывод и ошибки в другой поток или файл.
`contextlib.suppress` подавляет выбрасывание определенного типа исключений внутри блока кода.

### Обеспечение потокобезопасности с помощью `threading.Lock`

При выполнении процесса треды (threads) используют общую память. Если один тред выполняет операцию `a += 1`, 
а другой тред выполняет `a *= 2`, результат будет зависеть от порядка выполнения этих операций. По умолчанию 
этот порядок случаен, если разработчик его явно не задал. Кроме того, при длительных операциях, исходное значение 
переменной `a` может быть прочитано тредами почти одновременно, а затем они попытаются записать результат.
Такая ситуация зависимости результата программы от последовательности и расписания неконтролируемых событий 
называется состоянием гонки (race condition).
Чтобы предотвратить неожиданное переключение одного треда на другой, можно использовать `threading.Lock`. 
Чтобы "закрыть замок" для получения эксклюзивного права на общий ресурс, нужно вызвать метод `Lock.acquire()`. 
В этом случае в другом треде при попытке также заблокировать общий ресурс наступит пауза до тех пор, пока в первом 
треде не будет вызван метод `Lock.release()`.

### 
